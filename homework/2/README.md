### Оглавление
 - [Подготовка к третьей неделе](#third)
   - [pip](#pip)
   - [git](#git)
   - [heroku](#heroku)
   - [Нужные библиотеки](#libs)
 - [Домашнее задание](#hw)
   - [Дополнение CRM](#clients)
   - [Отдельные задачи](#classes)
     - [Класс Point](#point)
     - [Наследование](#inheritance)
     - [Расширение класса dict *](#dict)

<a name="third"></a>
# Подготовка к третьей неделе

### pip
Обязательно убедитесь, что у вас работает pip - пакетный менеджер Python (программа, с помощью которой мы будем устанавливать сторонние бибилиотеки). Можно проверить это попробовав запустить следующую комманду в командной строке (консоли):

```
$ pip -h
```

Если получаете сообщение о том, что pip - неизвестная команда, то нужно установить pip. Внимание, если у вас на машине уже есть python 2.7, то команда может назваться не `pip`, а `pip3.5`

[Полная статья, как установить pip на windows (англ.)](http://stackoverflow.com/questions/4750806/how-do-i-install-pip-on-windows) 

### Подготовка к 5-му и 6-му дню
На следующих занятиях мы будем разворачивать веб-сервер на Django с помощью сервиса Heroku.com. Учатники курса поделяться на команды для упрощения процесса. В каждой комманде, как и положенно в любой типичной группе разработки будет несколько ролей: архитектор, разработчики и как минимум один devops-админ (чтобы заливать наши приложения на сервер Heroku), поэтому я рекомендую всем заинтересованным - поставить следующие программы:

<a name="#git"></a>
 - [Система контроля версий git](https://git-scm.com/downloads) - устанавливается легко на каждой системе, на windows поставляется вместе с git bash

<a name="#heroku"></a>
 - [Heroku Toolbelt](https://toolbelt.heroku.com/) - для использования инструментария heroku toolbelt нужно зарегистрироваться на heroku.com 

<a name="#libs"></a>
**Какие библиотеки нам пригодятся?**

Вот набор библиотек и их версий, если у вас нет возможности скачать из прямо во время курса, то поставьте их заранее с помощью pip:
```
	Django==1.9.2
	gunicorn==19.4.5
	psycopg2==2.6.1
	whitenoise==2.0.6
	requests==2.9.1
	virtualenv=15.0.1
```

Ставяться они следующей командой:
```bash
$ pip install <имя библиотеки>==<номер версии>
$ #например
$ pip install Django=1.9.2
```
<a name="hw"></a>
# Домашнее задание на вторую неделю

<a name="clients"></a>
## Дописать программу с клиентами и продуктами

**Задача** - Расширить систему таким образом, чтобы у каждого объекта класса `Customer` появился целочисленный аттрибут `account` - хранящий информацию о количестве денег клиент. И если клиент пытаеться приобрести продукт у которого `price` больше, чем денег у пользователя, то покупка бы не совершалась, но печаталось сообщение, что у такого-то пользователя не достаточно денег:

```python
a = Customer('Joel', 32)
print(a.account) # 0 - изначально у пользователя нет денег на счете
a.buy('TV') # выводит сообщение `Customer: Joel does not have enough money on account. Need: 300, has: 0' 
```

Дополнить класс `Product` так чтобы у всех объектов этого класса появилось свойство `quantity` - количество этого продукта. Поддержать в методе `buy` у класса `Customer` количество покупаемых продуктов и в методе `add` у класса `Admin` количество добавляемых продуктов. 

Дополнительная сложность, если удасться реализовать соответсвующие записи в .json файлах. Например, изменять количество продуктов в .json файле, при покупке и добавлении. 

<a name="classes"></a>
## Отдельные задачи на понимание классов, методов и аттрибутов

<a name="point"></a>
### Класс Point

**1** - Написать маленький класс под названием `Point` - класс для представление точки на двумерном координатном поле. У объектов класса `Point` должны быть следующие свойства и методы:

```python
p = Point(10, 15) # первый аргумент - это координата по X, второй по Y
p.x # 10 
p.y # 15 
```

**2** - У объектов класса Point должен быть метод `length`, который возвращает расстояние от точки до начала координатной плоскости (т.е. гипотенузу прямоугольного треугольника с катетами равными p.x и p.y, см. рисунок) 

```
p.length() # 18.027756377319946
```

<img src="https://github.com/zefirka/python-as-first-language-course/blob/master/homework/2/scheme.png" width="400">

**3** - Поддержка метода `__str__`

Приведение точки к строке должно возвращать строку следующего вида:

```python
str(p) # 'Point <x: {координата x}, y: {координата y}>'
```

**4** - Точки можно суммировать и получать новую точку:

```python
a = Point(3, 4)
b = Point(5, 2)
c = a + b
print(c): # 'Point <x: 8, y: 6>'
# Как видите координаты просто суммируются c.x = a.x + b.x, c.y = a.y + b.y
```

Для того, чтобы реализовать суммирование нужно поддержать метод `__add__` в классе point: 
```python
def __add__(self, other_point):
	pass # этот метод принимает текущую точку и другую
```

**5*** - Поддержка метода `distance_from(point)`

Нужно написать метода `distance_from`, который принимает в качестве аргумента другую точку и возвращает расстояние от текущей точки до данной (см. рисунок):
```python
a = Point(5, 5)
b = Point(10, 5)
print(a.distance_from(b)) # 5
```
<img src="https://github.com/zefirka/python-as-first-language-course/blob/master/homework/2/scheme2.png" width="400">

<a name="inheritance"></a>
### Тренируемся в наследовании

Задача: спроектировать три класса, так чтобы один наследовал другой. Тема - свободная, но вот пример:
 - Класс всех животных `Animal` - есть свойство имени `name` и поддержка метода `__str__`
 - Класс всех млекопитающих `Mammal` - появляется статичное свойство (одно на все объекты) `kind` равное `mammal`, которое выводится при приведении объекта к строке
 - Класс `Monkey` - наследуется от `Mammal` - не перетирает свойство `kind`, но добавляет дополнительное сведение в свойстве `order` (отряд в животном царстве)

Пример использования:
```python
salamander = Animal('Mo-Mo')
salamander.name # 'Mo-Mo'
print(salamander) # 'Animal: Mo-mo, Kind: <unknown>'

cow = Mammal('Бурёнка')
cow.kind # 'Mammal'
cow.name # 'Бурёнка'
print(cow) # 'Animal: Бурёнка, Kind: Mammal'
cow.say() # 'Mooo'

monkey = Monkey('Boo')
print(monkey) # 'Animal: Boo, Kind: Mammal, Order: Monkey'
monkey.say()
```

Цель задачи в том, чтобы попрактиковаться в создании классов, наследовании методов и свойств, понимание конструкции `super()`. Вы можете выбирать любые три класса, лишь бы один наследовал другой и они были бы логично связаны между собой.

<a name="dict"></a>
###* Расширение класса dict

Нужно написать свой собственный класс, который наследуется от стандартного класса `dict`. Объекты этого класса поддерживают операцию сложения и вычитания:

Сложение:

```python
a = MyDict({'name': 'Alex'})
b = MyDict({'age': 25})

print(a + b) # собирает общий словарь
# {
#	 'name': 'Alex',
#	 'age': 25
# }

```

Вычитание:
```python
a = MyDict({'name': 'Alex', 'age': 25})
b = MyDict({'age': 32})

print(a - b) # убирает из a все ключи из b
# {
#     name': 'Alex'
# }
```